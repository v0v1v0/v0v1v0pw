<div class="container">

<table style="width: 100%;"><tr>
<td>cns</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Create new zeroed spectrum.</h2>

<h3>Description</h3>

<p>Part of a two-stage function suite designed to simulate locally stationary wavelet processes in conjunction with the LSWsim function. 
</p>


<h3>Usage</h3>

<pre><code class="language-R">cns(n, filter.number=1, family="DaubExPhase")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>n</code></td>
<td>
<p>The length of the simulated process that you want to produce. Must be a power of two (for this software).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. The options are "DaubExPhase" and "DaubLeAsymm".</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>This simple routine merely computes the time-ordered non-decimated wavelet transform of a zero vector of the same length as the eventual simulated series that you wish to produce. 
</p>
<p>If you look at this routine you will see that it is extremely simple. First, it checks to see whether the n that you supplied is a power of two. If it is then it creates a zero vector of that length. This is then non-decimated wavelet transformed with the appropriate wavelet. 
</p>
<p>The output can then be processed and then finally supplied to LSWsim for process simulation.
</p>


<h3>Value</h3>

<p>An object of class: <code>wd</code>, and, in fact, of the non-decimated variety. All wavelet coefficients of this are zero.  
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code>LSWsim</code>, <code>ewspec</code> 
</p>


</div>