<div class="container">

<table style="width: 100%;"><tr>
<td>modularity</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Modularity of a community structure of a graph</h2>

<h3>Description</h3>

<p>Computes the modularity of partitioning of a graph into sub-graphs. Similar to the
<code>modularity</code> function in the <code>igraph</code> package, but allows negative
edge weights.
</p>


<h3>Usage</h3>

<pre><code class="language-R">modularity(adj, membership, decomp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>adj</code></td>
<td>
<p>An adjacency matrix, which should be symmetric with zeros on the diagonal.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>membership</code></td>
<td>
<p>Vector of length equal to the number of graph nodes (columns/rows 
of <code>adj</code>) indicating the cluster/sub-graph each nodes belongs to.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>decomp</code></td>
<td>
<p>Logical. If <code>TRUE</code>, calculate the decomposition of modularity
by modules and nodes. Default <code>FALSE</code>.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The difference between this function and the function <code>modularity</code> 
in the package <code>igraph</code> is that this function can be used with an adjacency 
matrix with negative elements. This is a common case for matrices arrising from a 
for correlation matrix or another synchrony matrix. If the matrix is non-negative, 
the result of this function should be exactly the same as the result from 
<code>modularity</code> in the <code>igraph</code> package.
</p>


<h3>Value</h3>

<p><code>modularity</code> returns a list containing the following:
</p>
<table>
<tr style="vertical-align: top;">
<td><code>totQ</code></td>
<td>
<p>The total modularity. This is the only output if <code>decomp=FALSE</code></p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>modQ</code></td>
<td>
<p>The contribution of each module to the total modularity</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nodeQ</code></td>
<td>
<p>The contribution of each node to the total modularity</p>
</td>
</tr>
</table>
<h3>Note</h3>

<p>Adapted from code developed by Robert J. Fletcher, Jr.
</p>


<h3>Author(s)</h3>

<p>Jonathan Walter, <a href="mailto:jonathan.walter@ku.edu">jonathan.walter@ku.edu</a>; Lei Zhao, 
<a href="mailto:lei.zhao@cau.edu.cn">lei.zhao@cau.edu.cn</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Fletcher Jr., R.J., et al. (2013) Network modularity reveals critical scales 
for connectivity in ecology and evolution. Nature Communications. doi: 10.1038//ncomms3572.
</p>
<p>Gomez S., Jensen P. &amp; Arenas A. (2009). Analysis of community structure in networks 
of correlated data. Phys Rev E, 80, 016114.
</p>
<p>Newman M.E. (2006). Finding community structure in networks using the eigenvectors 
of matrices. Phys Rev E, 74, 036104.
</p>


<h3>See Also</h3>

<p><code>clust</code>, <code>cluseigen</code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">adj&lt;-matrix(0, 10, 10) # create a fake adjacency matrix
adj[lower.tri(adj)]&lt;-runif(10*9/2, -1, 1)
adj&lt;-adj+t(adj)
colnames(adj)&lt;-letters[1:10]
m&lt;-cluseigen(adj)
z&lt;-modularity(adj, m[[length(m)]], decomp=TRUE)

</code></pre>


</div>