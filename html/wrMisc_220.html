<div class="container">

<table style="width: 100%;"><tr>
<td>reorgByCluNo</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Reorganize matrix according to clustering-output</h2>

<h3>Description</h3>

<p>Reorganize input matrix as sorted by cluster numbers (and geometric mean) according to vector with cluster names, and index for sorting per cluster and per geometric mean.
In case <code>mat</code> is an array, the 3rd dimension will be considered as 'column' with arguments <code>useColumn</code> ( and <code>cluNo</code>, if it designs a 'column' of mat).
</p>


<h3>Usage</h3>

<pre><code class="language-R">reorgByCluNo(
  mat,
  cluNo,
  useColumn = NULL,
  meanCol = NULL,
  addInfo = TRUE,
  retList = FALSE,
  silent = FALSE,
  callFrom = NULL,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>mat</code></td>
<td>
<p>(matrix or data.frame) main input</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>cluNo</code></td>
<td>
<p>(positive integer, length to match nrow(dat) initial cluster numbers for each line of 'mat' (obtained by separate clustering or other segmentation) or may desinn column of <code>mat</code> to use as cluster-numbers</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>useColumn</code></td>
<td>
<p>(character or integer) the columns to use from <code>mat</code> as main data (default will use all, exept <code>cluCol</code> and/or <code>meanCol</code> if they design columns))</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>meanCol</code></td>
<td>
<p>(character or integer) alternative summarizing data for intra-cluster sorting (instead of geometric mean)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>addInfo</code></td>
<td>
<p>(logical) allows adding of columns 'index', 'geoMean' and 'cluNo'  (or array if <code>FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>retList</code></td>
<td>
<p>(logical) return as list of matrixes (or array if <code>FALSE</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>callFrom</code></td>
<td>
<p>(character) allow easier tracking of messages produced</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug</code></td>
<td>
<p>(logical) additional messages for debugging</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>This function returns a list or array (as 2- or 3 dim) with possible number of occurances for each of the 3 elements in nMax. Read results vertical : out[[1]] or out[,,1] .. (multiplicative) table for 1st element of nMax; out[,,2] .. for 2nd
</p>


<h3>See Also</h3>

<p>pairwise combinations <code>combn</code>, clustering <code>kmeans</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">dat1 &lt;- matrix(round(runif(24),2), ncol=3, dimnames=list(NULL,letters[1:3]))
clu &lt;- stats::kmeans(dat1, 5)$cluster
reorgByCluNo(dat1, clu) 

dat2 &lt;- cbind(dat1, clu=clu) 
reorgByCluNo(dat2, "clu") 
</code></pre>


</div>