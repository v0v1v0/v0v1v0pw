<div class="container">

<table style="width: 100%;"><tr>
<td>countChildrenParent</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Identify Children/Parent settings as a+b=c</h2>

<h3>Description</h3>

<p>This functions helps identifying fragments ('parent') characterized by a start- and end-position, that got split into 2  'children' fragments. 
So, each one of the new 'children' conserves either the start- or end-site of the parent and the the remaining ends are on consecutive positions.
For example if the sequence 'BCDEFG' (parent) gets split into 'BCD' (positions 1-3) and 'EFG' (positions 4-6), 
this will be identified as a children/parent 'family' which could be represented as 'a+b=c' case.
Note : At this point only settings with 2 children are considered, for more complex scenarions one may build trees using <code>buildTree</code> (however, this function does not identify 'parents').
In proteomics-applications some start- and end-sites may occur multiple times, representing eg unmodified and modified versions of the same basal peptide-sequence.
Such duplicated start- and end-cases are handeled as allowed, a 'child' (characterized by its start- and end-position) may occur multiple times, and the 
corresponding redundant rownames (eg peptide sequence like 'BCD') will be conserved. However, information reflecting eg different peptide modifications must be stored separately.
If redudant start- and end-sites accur with different row-names, repeated start- and end-sites will display <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class="language-R">countChildrenParent(
  fragments,
  output = "count",
  silent = FALSE,
  callFrom = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>fragments</code></td>
<td>
<p>(matrix or data.frame) integer values in 1st column, for start site of fragment, and in 2nd column as end-sites of fragments, rownames as IDs</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>output</code></td>
<td>
<p>(character) choose simply returning results as counts or as list with <code>$counts</code> and <code>$detailIndex</code> (list with details showing each child1,child2 &amp; parent)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>silent</code></td>
<td>
<p>(logical) suppress messages</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>callFrom</code></td>
<td>
<p>(character) allows easier tracking of message(s) produced</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>either numeric vector with cumulated counts (corresponding to rows of <code>fragments</code>) or list with $count and $detailIndex (list with indexes refering to non-redundant entries of all a+b=c settings identified)
</p>


<h3>See Also</h3>

<p><code>simpleFragFig</code> for graphical representation,<code>countSameStartEnd</code>; for building longer consecutive trees (without identification of 'parent') <code>buildTree</code> and  <code>contribToContigPerFrag</code>
</p>


<h3>Examples</h3>

<pre><code class="language-R">frag3 &lt;- cbind(beg=c(4,2,3,7,13,13,15, 2,9,2,9), end=c(14,6,12,8,18,20,20, 8,12,12,18)) 
rownames(frag3) &lt;- c("K","A","E","B","C","D","F", "H","G","I","J")
countChildrenParent(frag3)
## example with duplicate start- and end-position positions
frag3c &lt;- cbind(beg=c(4,2,3,7, 7,13, 13,13,15, 2,9,2,9,9),
  end=c(14,6,12,8, 8,18, 18,20,20, 8,12,12,12,18))
rownames(frag3c) &lt;- c("K","A","E", "B","B", "C","C","D","F", "H","G","I","G","J")
countChildrenParent(frag3c, out="det")

</code></pre>


</div>