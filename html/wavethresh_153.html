<div class="container">

<table style="width: 100%;"><tr>
<td>plot.wst</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Plot packet-ordered non-decimated wavelet transform coefficients.
</h2>

<h3>Description</h3>

<p>This function plots packet-ordered non-decimated wavelet transform
coefficients arising from a <code>wst.object</code> object.
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'wst'
plot(x, main = "Nondecimated Wavelet (Packet) Decomposition", 
    sub, first.level = 5, scaling = "compensated", dotted.turn.on = 5, 
    aspect = "Identity", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>x</code></td>
<td>
<p>The wst object whose coefficients you wish to plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>main</code></td>
<td>
<p>The main title of the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>sub</code></td>
<td>
<p>A subtitle for the plot.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>first.level</code></td>
<td>
<p>The first resolution level to begin plotting at.
This argument can be quite useful when you want to suppress some of
the coarser levels in the diagram.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>scaling</code></td>
<td>
<p>How you want the coefficients to be scaled.
The options are: <code>global</code> - one scale factor is chosen for the
whole plot. The scale factor depends on the coefficient to be
included on the plot that has the largest absolute value.
The global option is useful when comparing coefficients that might
appear anywhere in the plot;
<code>by.level</code> - a scale factor is chosen for each resolution level
in the plot. The scale factor for a level depends on the coefficient
in that level that has the largest absolute value. The
<code>by.level</code> option is useful when you wish to compare coefficients
within a resolution level.
The other option is <code>compensated</code> which is the same as global
except for that finer scales' coefficients are scaled up by a factor
of SQRT(2)
</p>
<p>I don't know why compensated is the default option? It is a bit silly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>dotted.turn.on</code></td>
<td>
<p>The plot usually includes some dotted vertical bars that
separate wavelet packets to make it clearer which packets are which.
This option controls the coarsest resolution level at which dotted
lines appear. All levels equal to and finer than this level will
receive the vertical dotted lines.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aspect</code></td>
<td>
<p>A transform to apply to the coefficients before plotting.
If the coefficients are complex-valued and aspect="Identity" then
the modulus of the coefficients are plotted.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Other arguments to plot</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>A packet-ordered non-decimated wavelet object contains coefficients
of a signal (usually obtained by the <code>wst</code>
packet-ordered non-decimated wavelet transform, but also
functions that derive such objects, such as <code>threshold.wst</code>).
</p>
<p>A packet-ordered nondecimated wavelet object, x,
possesses <code>nlevelsWT(x)</code> resolution levels.
In WaveThresh the coarsest level is level 0 and the finest is level
<code>nlevelsWT-1</code>. For packet-ordered nondecimated wavelet
the number of blocks (packets) at
level <code>j</code> is <code>2^(nlevelsWT-j)</code>.
</p>
<p>This function plots the coefficients.
At the bottom of the plot the original input function (if present) is plotted.
Then levels above the original plot successively coarser wavelet 
coefficients.
Each packet of coefficients is plotted within dotted vertical lines.
At the finest level there are two packets: one (the left one) correspond to
the wavelet coefficients that would be obtained using the (standard)
decimated wavelet transform function, <code>wd</code>,
and the other packet are those coefficients that would have been obtained
using the standard decimated wavelet transform after a unit cyclic shift.
</p>
<p>For coarser levels there are more packets corresponding to different cyclic
shifts (although the computation is not performed using shifting operations
the effect is the same). For full details see Nason and Silverman, 1995.
</p>
<p>Packets are drawn on the plot and can be separated by vertical dotted lines.
The resolution levels at which this happens can be controlled by the
<code>dotted.turn.on</code> option.
The coarsest resolution level to be drawn is controlled by
the <code>first.level option</code>.
</p>
<p><em>It should be noted that the packets referred to here are just the
blocks of nondecimated wavelet coefficients in a packet-ordering.
These are different to wavelet packets (produced by <code>wp</code>)
and nondecimated wavelet packets (produced by <code>wpst</code>)</em>
</p>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code>MaNoVe</code>,<code>threshold.wst</code>, <code>wst</code>, <code>wst.object</code></p>


<h3>Examples</h3>

<pre><code class="language-R">#
# Generate some test data
#
v &lt;- DJ.EX()$heavi
#
# Let's plot these to see what they look like
#
## Not run: plot(v, type="l")
#
# Do a packet-ordered non-decimated wavelet packet transform
#
vwst &lt;- wst(v)
#
# Now plot the coefficients
#
## Not run: plot(vwst)
#
# Note that the "original" function is at the bottom of the plot.
# The finest scale coefficients (two packets) are immediately above.
# Increasingly coarser scale coefficients are above that!
#
</code></pre>


</div>