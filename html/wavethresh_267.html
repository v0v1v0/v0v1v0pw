<div class="container">

<table style="width: 100%;"><tr>
<td>wst2D</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>(Packet-ordered) 2D non-decimated wavelet transform.</h2>

<h3>Description</h3>

<p>This function computes the (packet-ordered) 2D non-decimated wavelet transform
</p>


<h3>Usage</h3>

<pre><code class="language-R">wst2D(m, filter.number=10, family="DaubLeAsymm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>m</code></td>
<td>
<p>A matrix containing the image data that you wish to decompose. Each dimension of the matrix must be the same power of 2.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>filter.number</code></td>
<td>
<p>This selects the smoothness of wavelet that you want to use in the decomposition. By default this is 10, the Daubechies least-asymmetric orthonormal compactly supported wavelet with 10 vanishing moments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>family</code></td>
<td>
<p>specifies the family of wavelets that you want to use. Two popular options are "DaubExPhase" and "DaubLeAsymm" but see the help for <code>filter.select</code> for more possibilities.</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p>The <code>wst2D</code> computes the (packet-ordered) 2D non-decimated discrete wavelet transform. Such a transform may be used in wavelet shrinkage of images using the <code>AvBasis.wst2D</code> function to perform an "average-basis" inverse. Such a transform was used to denoise images in the paper by Lang, Guo, Odegard, Burrus and Wells, 1995. 
</p>
<p>The algorithm works by mixing the HH, GH, HG and GG image operators of the 2D (decimated) discrete wavelet transform (see Mallat, 1989 and the implementation in WaveThresh called <code>imwd</code>) with the shift operator S (as documented in Nason and Silverman, 1995) to form new operators (as given in the help to <code>getpacket.wst2D</code>). 
</p>
<p>Subimages can be obtained and replaced using the <code>getpacket.wst2D</code> and <code>putpacket.wst2D</code> functions. 
</p>
<p>This function is a 2D analogue of the (packet-ordered) non-decimated discrete wavelet transform implemented in WaveThresh as <code>wst</code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>wst2D</code>. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9.5 Copyright Guy Nason 1998</p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>See Also</h3>

<p><code>AvBasis.wst2D</code>, <code>getpacket.wst2D</code>, <code>imwd</code>, <code>plot.wst2D</code>, <code>print.wst2D</code>, <code>putpacket.wst2D</code>, <code>summary.wst2D</code>, <code>wst2D.object</code>.
</p>


<h3>Examples</h3>

<pre><code class="language-R">#
# We shall use the lennon image.
#
data(lennon)
#
#
# Now let's apply the (packet-ordered) 2D non-decimated DWT to it...
# (using the default wavelets)
#
uawst2D &lt;- wst2D(lennon)
#
# One can use the function plot.wst2D to get
# a picture of all the resolution levels. However, let's just look at them
# one at a time.
#
# How many levels does our uawst2D object have? 
#
nlevelsWT(uawst2D)
#[1] 8
#
# O.k. Let's look at resolution level 7
#
## Not run: image(uawst2D$wst2D[8,,])
#
#
# There are four main blocks here (each of 256x256 pixels) which themselves
# contain four sub-blocks. The primary blocks correspond to the no shift,
# horizontal shift, vertical shift and "horizontal and vertical" shifts
# generated by the shift S operator. Within each of the 256x256 blocks
# we have the "usual" Mallat smooth, horizontal, vertical and diagonal
# detail, with the smooth in the top left of each block.
#
# Let's extract the smooth, with no shifts at level 7 and display it
#
## Not run: image(getpacket(uawst2D, level=7, index=0, type="S"))
#
#
# Now if we go two more resolution levels deeper we have now 64x64 blocks
# which contain 32x32 subblocks corresponding to the smooth, horizontal,
# vertical and diagonal detail. 
#
#
# Groovy eh?
</code></pre>


</div>