<div class="container">

<table style="width: 100%;"><tr>
<td>LocalSpec.wd</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Compute Nason and Silverman raw or smoothed wavelet periodogram. </h2>

<h3>Description</h3>

<p><em>This smoothing in this function is now obsolete</em>. You should now use the function <code>ewspec</code>.
</p>
<p>This function computes the Nason and Silverman raw or smoothed wavelet periodogram as described by Nason and Silverman (1995). 
</p>


<h3>Usage</h3>

<pre><code class="language-R">## S3 method for class 'wd'
LocalSpec(wdS, lsmooth="none", nlsmooth=FALSE, prefilter=TRUE,
  verbose=FALSE, lw.number=wdS$filter$filter.number,
  lw.family=wdS$filter$family, nlw.number=wdS$filter$filter.number,
  nlw.family=wdS$filter$family, nlw.policy="LSuniversal",
  nlw.levels=0:(nlevelsWT(wdS) - 1), nlw.type="hard", nlw.by.level=FALSE,
  nlw.value=0, nlw.dev=var, nlw.boundary=FALSE, nlw.verbose=FALSE,
  nlw.cvtol=0.01, nlw.Q=0.05, nlw.alpha=0.05, nlw.transform=I,
  nlw.inverse=I, debug.spectrum=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<p>Note that all options beginning "nlw" are only used if nlsmooth=T, i.e. iff NONLINEAR wavelet smoothing is used. 
</p>
<table>
<tr style="vertical-align: top;">
<td><code>wdS</code></td>
<td>
<p>The stationary wavelet transform object that you want to smooth or square.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lsmooth</code></td>
<td>
<p>Controls the LINEAR smoothing. There are three options: "none", "Fourier" and "wavelet". They are described below. Note that Fourier begins with a capital "F".</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlsmooth</code></td>
<td>
<p>A switch to turn on (or off) the NONLINEAR wavelet shrinkage of (possibly LINEAR smoothed) local power coefficients. This option is either TRUE (to turn on the smoothing) or FALSE (to turn it off).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>prefilter</code></td>
<td>
<p>If TRUE then apply a prefilter to the actual stationary wavelet coefficients at each level. This is a low-pass filter that cuts off all frequencies above the highest frequency allowed by the (Littlewood-Paley) wavelet that bandpassed the current level coefficients. If FALSE then no prefilter is applied.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>verbose</code></td>
<td>
<p>If TRUE then the function chats about what it is doing. Otherwise it is silent.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lw.number</code></td>
<td>
<p>If wavelet LINEAR smoothing is used then this option controls the <code>filter number</code> of the wavelet within the family used to perform the LINEAR wavelet smoothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>lw.family</code></td>
<td>
<p>If wavelet LINEAR smoothing is used then this option controls the <code>family</code> of the wavelet used to perform the LINEAR wavelet smoothing.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.number</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the <code>filter number</code> of the wavelet used to perform the wavelet shrinkage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.family</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the <code>family</code> of the wavelet used to perform the wavelet shrinkage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.policy</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the levels to use when performing wavelet shrinkage (see <code>threshold.wd</code> for different policy choices).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.levels</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the levels to use when performing wavelet shrinkage (see <code>threshold.wd</code> for a detailed description of how levels can be chosen).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.type</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the type of thresholding used in the wavelet shrinkage (either "hard" or "soft", but see <code>threshold.wd</code> for a list). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.by.level</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls whether level-by-level thresholding is used or if one threshold is chosen for all levels (see <code>threshold.wd</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.value</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls if a manual (or similar) policy is supplied to <code>nlw.policy</code> then the nlw.value option carries the manual threshold value (see <code>threshold.wd</code>). </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.dev</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the type of variance estimator that is used in wavelet shrinkages (see <code>threshold.wd</code>). One possibility is the Splus var() function, another is the WaveThresh function <code>madmad</code>().</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.boundary</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls whether boundary coefficients are also thresholded (see <code>threshold.wd</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.verbose</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls whether the threshold function prints out messages as it thresholds levels (see <code>threshold.wd</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.cvtol</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the optimization tolerance is cross-validation wavelet shrinkage is used (see <code>threshold.wd</code>)</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.Q</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the Q value for wavelet shrinkage (see <code>threshold.wd</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.alpha</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the alpha value for wavelet shrinkage (see <code>threshold.wd</code>).</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.transform</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls a transformation that is applied to the squared (and possibly linear smoothed) stationary wavelet coefficients before shrinkage. So, for examples, you might want to set <code>nlw.transform=log</code> to perform wavelet shrinkage on the logs of the squared (and possibly linear smoothed) stationary wavelet coefficients. </p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>nlw.inverse</code></td>
<td>
<p>If NONLINEAR wavelet smoothing is also used then this option controls the inverse transformation that is applied to the wavelet shrunk coefficients before they are put back into the stationary wavelet transform structure. So, for examples, if the <code>nlw.transform</code> is <code>log()</code> you should set the inverse to <code>nlw.inverse=exp</code>.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>debug.spectrum</code></td>
<td>
<p>If this option is <code>T</code> then spectrum plots are produced at each stage of the squaring/smoothing. Therefore if you put in the non-decimated wavelet transform of white noise you can get a fair idea of how the coefficients are filtered at each stage.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>any other arguments</p>
</td>
</tr>
</table>
<h3>Details</h3>

<p><em>This smoothing in this function is now obsolete.</em> Use the function <code>ewspec</code> instead. However, this function is still useful for computing the raw periodogram. 
</p>
<p>This function attempts to produce a picture of local time-scale power of a signal. There are two main components to this function: linear smoothing of squared coefficients and non-linear smoothing of these. Neither, either or both of these components may be used to process the data. The function expects a non-decimated wavelet transform object (of class wd, type="station") such as that produced by the <code>wd</code>() function with the type option set to "<code>station</code>". The following paragraphs describe the various methods of smoothing. 
</p>
<p><b>LINEAR SMOOTHING</b>. There are three varieties of linear smoothing. None simply squares the coefficients. Fourier and wavelet apply linear smoothing methods in accordance to the prescription given in Nason and Silverman (1995). Each level in the SWT corresponds to a band-pass filtering to a frequency range [sl, sh]. After squaring we obtain power in the range [0, 2sl] and [2sl, 2sh]. The linear smoothing gets rid of the power in [2sl, 2sh]. The Fourier method simply applies a discrete Fourier transform (rfft) and cuts off frequencies above 2sl. The wavelet method is a bit more suble. The DISCRETE wavelet transform is taken of a level (i) and all levels within the DWT, j, where j&gt;i are set to zero and then the inverse is taken. Approximately this performs the same operation as the Fourier method only faster. By default the same wavelets are used to perform the linear smoothing as were used to compute the stationary wavelet transform in the first place. This can be changed by altering <code>lw.number</code> and <code>lw.family</code>.  
</p>
<p><b>NONLINEAR SMOOTHING</b>. After either of the linear smoothing options above it is possible to use wavelet shrinkage upon each level in the squared (and possibly Fourier or wavelet linear smoothed) to denoise the coefficients. This process is akin to smoothing the ordinary periodogram. All the usual wavelet shrinkage options are available as <code>nlw</code>.* where * is one of the usual <code>threshold.wd</code> options. By default the same wavelets are used to perform the wavelet shrinkage as were used to compute the non-decimated wavelet transform. These wavelets can be replaced by altering <code>nlw.number</code> and <code>nlw.family</code>. Also, it is possible to transform the squared (and possibly smoothed coefficients) before applying wavelet shrinkage. The transformation is effected by supplying an appropriate transformation function (AND ITS INVERSE) to <code>nlw.transform</code> and <code>nlw.inverse</code>. (For examples, <code>nlw.transform=log</code> and<code> nlw.inverse=exp</code> might be a good idea). 
</p>


<h3>Value</h3>

<p>An object of class <code>wd</code> a time-ordered non-decimated wavelet transform. Each level of the returned object contains a smoothed wavelet periodogram. Note that this is <b>not</b> the <em>corrected</em> smoothed wavelet periodogram, or the <em>evolutionary wavelet spectrum</em>. Use the function <code>ewspec</code> to compute the evolutionary wavelet spectrum. 
</p>


<h3>RELEASE</h3>

<p>Version 3.9 Copyright Guy Nason 1998 </p>


<h3>Author(s)</h3>

<p>G P Nason</p>


<h3>References</h3>

<p>Nason and Silverman, (1995). </p>


<h3>See Also</h3>

<p><code>ewspec</code>, 
</p>


<h3>Examples</h3>

<pre><code class="language-R">#
# This function is obsolete. See ewspec()
#
# Compute the raw periodogram of the BabyECG
# data using the Daubechies least-asymmetric wavelet $N=10$.
#
data(BabyECG)
babywdS &lt;- wd(BabyECG, filter.number=10, family="DaubLeAsymm", type="station")
babyWP &lt;- LocalSpec(babywdS, lsmooth = "none", nlsmooth = FALSE)
## Not run: plot(babyWP, main="Raw Wavelet Periodogram of Baby ECG")
#
# Note that the lower levels of this plot are too large. This is partly because
# there are "too many" coefficients at the lower levels. For a better
# picture of the local spectral properties of this time series see
# the examples section of ewspec
#
# Other results of this function can be seen in the paper by
# Nason and Silverman (1995) above.
#
</code></pre>


</div>