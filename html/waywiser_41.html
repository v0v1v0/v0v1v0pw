<div class="container">

<table style="width: 100%;"><tr>
<td>ww_multi_scale</td>
<td style="text-align: right;">R Documentation</td>
</tr></table>
<h2>Evaluate metrics at multiple scales of aggregation</h2>

<h3>Description</h3>

<p>Evaluate metrics at multiple scales of aggregation
</p>


<h3>Usage</h3>

<pre><code class="language-R">ww_multi_scale(
  data = NULL,
  truth,
  estimate,
  metrics = list(yardstick::rmse, yardstick::mae),
  grids = NULL,
  ...,
  na_rm = TRUE,
  aggregation_function = "mean",
  autoexpand_grid = TRUE,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr style="vertical-align: top;">
<td><code>data</code></td>
<td>
<p>Either: a point geometry <code>sf</code> object containing the columns
specified by the <code>truth</code> and <code>estimate</code> arguments; a <code>SpatRaster</code> from
the <code>terra</code> package containing layers specified by the <code>truth</code> and <code>estimate</code>
arguments; or <code>NULL</code> if <code>truth</code> and <code>estimate</code> are <code>SpatRaster</code> objects.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>truth, estimate</code></td>
<td>
<p>If <code>data</code> is an <code>sf</code> object, the names (optionally
unquoted) for the columns in <code>data</code> containing the true and predicted values,
respectively. If <code>data</code> is a <code>SpatRaster</code> object, either (quoted) layer names or
indices which will select the true and predicted layers, respectively, via
<code>terra::subset()</code> If <code>data</code> is <code>NULL</code>, <code>SpatRaster</code> objects with a single
layer containing the true and predicted values, respectively.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>metrics</code></td>
<td>
<p>Either a <code>yardstick::metric_set()</code> object, or a list of
functions which will be used to construct a <code>yardstick::metric_set()</code> object
specifying the performance metrics to evaluate at each scale.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>grids</code></td>
<td>
<p>Optionally, a list of pre-computed <code>sf</code> or <code>sfc</code> objects
specifying polygon boundaries to use for assessments.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>...</code></td>
<td>
<p>Arguments passed to <code>sf::st_make_grid()</code>.
<strong>You almost certainly should provide these arguments as lists.</strong>
For instance, passing <code>n = list(c(1, 2))</code> will create a single 1x2 grid;
passing <code>n = c(1, 2)</code> will create a 1x1 grid <em>and</em> a 2x2 grid.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>na_rm</code></td>
<td>
<p>Boolean: Should polygons with NA values be removed before
calculating metrics? Note that this does <em>not</em> impact how values are
aggregated to polygons: if you want to remove NA values before aggregating,
provide a function to <code>aggregation_function</code> which will remove NA values.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>aggregation_function</code></td>
<td>
<p>The function to use to aggregate predictions and
true values at various scales, by default <code>mean()</code>. For the <code>sf</code> method,
you can pass any function which takes a single vector and returns a scalar.
For raster methods, any function accepted by
<code>exactextractr::exact_extract()</code> (note that built-in function names must be
quoted). Note that this function does <em>not</em> pay attention to the value of
<code>na_rm</code>; any NA handling you want to do during aggregation should be handled
by this function directly.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>autoexpand_grid</code></td>
<td>
<p>Boolean: if <code>data</code> is in geographic coordinates and
<code>grids</code> aren't provided, the grids generated by <code>sf::st_make_grid()</code> may not
contain all observations. If <code>TRUE</code>, this function will automatically expand
generated grids by a tiny factor to attempt to capture all observations.</p>
</td>
</tr>
<tr style="vertical-align: top;">
<td><code>progress</code></td>
<td>
<p>Boolean: if <code>data</code> is <code>NULL</code>, should aggregation via
<code>exactextractr::exact_extract()</code> show a progress bar? Separate progress bars
will be shown for each time <code>truth</code> and <code>estimate</code> are aggregated.</p>
</td>
</tr>
</table>
<h3>Value</h3>

<p>A tibble with six columns: <code>.metric</code>, with the name
of the metric that the row describes; <code>.estimator</code>, with the name of the
estimator used, <code>.estimate</code>, with the output of the metric function;
<code>.grid_args</code>, with the arguments passed to <code>sf::st_make_grid()</code> via <code>...</code>
(if any), <code>.grid</code>, containing the grids used to aggregate predictions,
as well as the aggregated values of <code>truth</code> and <code>estimate</code> as well as the
count of non-NA values for each, and <code>.notes</code>, which (if <code>data</code> is an <code>sf</code>
object) will indicate any observations which were not used in a given
assessment.
</p>


<h3>Raster inputs</h3>

<p>If <code>data</code> is <code>NULL</code>, then <code>truth</code> and <code>estimate</code> should both be <code>SpatRaster</code>
objects, as created via <code>terra::rast()</code>. These rasters will then be
aggregated to each grid using <code>exactextractr::exact_extract()</code>. If <code>data</code>
is a <code>SpatRaster</code> object, then <code>truth</code> and <code>estimate</code> should be indices to
select the appropriate layers of the raster via <code>terra::subset()</code>.
</p>
<p>Grids are calculated using the bounding box of <code>truth</code>, under the assumption
that you may have extrapolated into regions which do not have matching "true"
values. This function does not check that <code>truth</code> and <code>estimate</code> overlap at
all, or that they are at all contained within the grid.
</p>


<h3>Creating grid blocks</h3>

<p>The grid blocks can be controlled by passing arguments to
<code>sf::st_make_grid()</code> via <code>...</code>. Some particularly useful arguments include:
</p>

<ul>
<li> <p><code>cellsize</code>: Target cellsize, expressed as the "diameter" (shortest
straight-line distance between opposing sides; two times the apothem)
of each block, in map units.
</p>
</li>
<li> <p><code>n</code>: The number of grid blocks in the x and y direction (columns, rows).
</p>
</li>
<li> <p><code>square</code>: A logical value indicating whether to create square (<code>TRUE</code>) or
hexagonal (<code>FALSE</code>) cells.
</p>
</li>
</ul>
<p>If both <code>cellsize</code> and <code>n</code> are provided, then the number of blocks requested
by <code>n</code> of sizes specified by <code>cellsize</code> will be returned, likely not
lining up with the bounding box of <code>data</code>. If only <code>cellsize</code>
is provided, this function will return as many blocks of size
<code>cellsize</code> as fit inside the bounding box of <code>data</code>. If only <code>n</code> is provided,
then <code>cellsize</code> will be automatically adjusted to create the requested
number of cells.
</p>
<p>Grids are created by mapping over each argument passed via <code>...</code>
simultaneously, in a similar manner to <code>mapply()</code> or <code>purrr::pmap()</code>. This
means that, for example, passing <code>n = list(c(1, 2))</code> will create a single
1x2 grid, while passing <code>n = c(1, 2)</code> will create a 1x1 grid <em>and</em> a 2x2
grid. It also means that arguments will be recycled using R's standard
vector recycling rules, so that passing <code>n = c(1, 2)</code> and <code>square = FALSE</code>
will create two separate grids of hexagons.
</p>
<p>This function can be used for geographic or projected coordinate reference
systems and expects 2D data.
</p>


<h3>References</h3>

<p>Riemann, R., Wilson, B. T., Lister, A., and Parks, S. (2010). "An effective
assessment protocol for continuous geospatial datasets of forest
characteristics using USFS Forest Inventory and Analysis (FIA) data."
Remote Sensing of Environment 114(10), pp 2337-2352,
doi: 10.1016/j.rse.2010.05.010 .
</p>


<h3>Examples</h3>

<pre><code class="language-R">
data(ames, package = "modeldata")
ames_sf &lt;- sf::st_as_sf(ames, coords = c("Longitude", "Latitude"), crs = 4326)
ames_model &lt;- lm(Sale_Price ~ Lot_Area, data = ames_sf)
ames_sf$predictions &lt;- predict(ames_model, ames_sf)

ww_multi_scale(
  ames_sf,
  Sale_Price,
  predictions,
  n = list(
    c(10, 10),
    c(1, 1)
  ),
  square = FALSE
)

# or, mostly equivalently
# (there will be a slight difference due to `autoexpand_grid = TRUE`)
grids &lt;- list(
  sf::st_make_grid(ames_sf, n = c(10, 10), square = FALSE),
  sf::st_make_grid(ames_sf, n = c(1, 1), square = FALSE)
)
ww_multi_scale(ames_sf, Sale_Price, predictions, grids = grids)

</code></pre>


</div>